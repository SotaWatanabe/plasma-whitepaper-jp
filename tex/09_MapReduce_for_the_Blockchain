\section{ブロックチェーンのためのMapReduce}
MapReduce上で計算できるほぼ全てのものがこのチェーン上でも同様に計算可能でなければならない。これは我々のブロックチェーンにおける計算とプログラミングの考え方に重大なパラダイムシフトを要する。これはMapReduceではあるが、不正証明がともにある。それぞれのノードはブロックチェーンを表す。これは前のセクションで述べられたように、Plasmaチェーンの構造と高度に互換性がある。
例えば、もしユーザーが単純なワードカウントをやりたいとして、あなたはreduce関数を実行するチェーンのマークルツリーを作れる。もし不正の証拠がそこにあれば、そのノード（チェーン）はペナルティを受ける。もし加算のreduce関数をあなたが生成できるなら、あなたは平均もまた生成できる。例えば平均価格などだ。Map関数はただ計算処理をここのチェーンに送って、結果を返すだけだ。明らかにデータスループットの制約があり、それがreduceの不正証明が必要な理由だ。任意の計算処理、というのは不可能で、しかし多くの種類の問題を解くことができる。たいてい、ソートアルゴリズムのようなメモリ使用量に制約をかけられる問題は解決できてる。それはPlasmaチェーン間のトラフィックとトレードオフだ。

もしノードが計算を証明する実際のブロックを生成できなかったとき、彼らの結果は廃棄され、ロールバックする。覚えておいてほしいのが、これはMapReduceが行うような計算のスケーラビリティを保証するわけではなく（なぜならコンセンサスを維持するためにチェーンを監視しなければいけないから）、しかし、活動の強制とアクターたちのための拡張性を得る。結果として、はじめにわかる限界は、その特定の計算に関わる当事者たちは、その一連の計算を監視しなければならないという事実だ。もしその当事者が小規模な領域だけを監視していればいいのであれば、それはそれでよいのだが、しかしその当事者が計算に関わる全体を監視しなければならないとき、スケーラビリティのメリットは得られない（scalable assuranceしか得られない）。それはつまり、この方法で多くの問題が解決される。例えばDEX(Decentralized EXchange/もし他の皆の処理が強制可能であなたが詳細を気にしないなら、あなたのmapされた計算の集合はあなたのトレードに関するもの)などだ。

ブロックのフォーマットはTrueBitの設計にある計算可能なものと互換可能なものでないといけない。そこには状態へのコミット（UTXOと状態遷移の証明を可能にする状態木を構築できるように）、アカウントの木（子チェーンと複雑な状態遷移のために）、手数料のコミット（状態遷移をコミットするための手数料）、マークル化されたトランザクション、親/子チェーンから渡されたデータへのコミット、観測された親/子のブロック（再整列の防止のため）、そして様々なビジネスロジック（例：ワードカウントの例はマークル化されてソートされた単語がどこで見つかったかのコミット）がある。マークルコミットを構築することで、不正な状態遷移を証明できるルート/親チェーンで証明可能なスマートコントラクトを作成できる。このフォーマットと互換可能でないいくつかの問題セットがあるが、過剰なメモリ要件なしの一般的な計算は可能である。不正証明に許される最大のデータと同値な形で、計算のための最大メモリサイズが扱われるメンタルモデルを持つとよい。


一連のmapとreduceの関数は、それによって処理する義務のあるような形でブロックチェーンを操作することを可能にする。これは親と子のチェーンに処理の義務を作るように要求する。子は親の渡したものをデータに含まなければならず、さもなくばチェーンは停止する。親チェーンは子に計算を強制でき、もし子が停止すればその矯正は親のチェーンで発生し、その場で証明を検証する。最初のTrueBitの設計での脅威はチェーンの停止に関わるもので、もし子チェーンが止まってもオペレーションが継続できるように設計されねばらなず、けれどもそれは多大な、特に時間に関する複雑さを要求することとなる（データセットが変更可能で、かつ時系列的生合成を持つと、特定の問題を片付けるのに大変骨が折れる）。
子チェーンとのmapとreduceのフレームワークでブロックチェーンの計算を設計することによって、既存の計算機科学の研究を利用し、直接ブロックチェーンの分散システムの問題に適用することが可能になる。多様なビジネスアプリケーションを生み出すSolidityコントラクトをスケーラブルなやり方で実装することも可能である。
そして個々のチェーンはただ計算し、活動を検証するだけでそれが作られるのだ。


